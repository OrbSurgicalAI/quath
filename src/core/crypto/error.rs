#[derive(thiserror::Error, Debug, Clone)]
pub enum ServerProtocolError {
    #[error("Failed to verify the signature attached to the token.")]
    FailedToVerifyTokenSignature,
    #[error("Failed to encapsulation the key.")]
    EncapsulationFailed,
    #[error("Failed to sign a response.")]
    FailedToSignResponse,
    #[error("Failed to verify that the client cycling actually owns the new key.")]
    FailedToVerifyNewCycleKey,
    #[error("Failed to verify that the client cycling owns the old cycling key.")]
    FailedToVerifyOldKeyDuringCycle,
    #[error("Failed to verify that the k-proof during registration was generated correctly.")]
    FailedToVerifyKProof,
    #[error("Failed to verify that the a-proof during registration was generated by an admin.")]
    FailedToVerifyAProof,
    #[error("The token was rejected because it was not in the specified server time interval")]
    TokenOutOfInterval,
    #[error("The alledged admin claimed by the client does not actually exist")]
    NoAdminFound,
    #[error("The UUID requested for registration is not unique.")]
    UuidTaken,
    #[error("The public key is not unique.")]
    PublicKeyNotUnique,
    #[error("Miscelleaneous error.")]
    Misc(String),
    #[error("Failed to store the key.")]
    StoreFailure(String),
    #[error("The client requires a cycle as the key has expired.")]
    CycleRequired,
    #[error("The token is in a revocation list.")]
    TokenInRevocationList,
    #[error("This token has already been stamped. It is now being revoked.")]
    TokenDuplicate,
    #[error("Invalid client UUID, does not exist.")]
    InvalidClientUuid,
    #[error("Token was expired.")]
    TokenExpired,
    #[error("Token does not exist, could not verify.")]
    TokenDoesNotExist,
    #[error("Server could not verify the permission string.")]
    TokenPermissionError(String),
    #[error("Failed to verify token revocation request")]
    FailedToVerifyRevocationRequest,
    #[error("Failed to verify the signature on the hash sent for authenticating the deregistering request.")]
    FailedToVerifyDeregisterHash,
    #[error("The request to revoke a token was unauthorized.")]
    UnauthorizedTokenRequest,
    #[error("The request to revoke a token was unauthorized.")]
    UnauthorizedDeregisterRequest,
    #[error("The claimant behind the revocation request could not be located and thus serviced.")]
    RevocationClaimantNotFound,
    #[error("Internal error relating to database")]
    MalformedPkFetch,
    #[error("Deregisterd")]
    DeregistrationClaimantNotFound,
    #[error("Deregistration target not found.")]
    DeregstrationUnchanged,
    #[error("error in deregisterd")]
    DeregistrationError(String)
}
impl ServerProtocolError {
    pub fn error_name(&self) -> &'static str {
        match self {
            Self::FailedToVerifyTokenSignature => "FailedToVerifyTokenSignature",
            Self::EncapsulationFailed => "EncapsulationFailed",
            Self::FailedToSignResponse => "FailedToSignResponse",
            Self::FailedToVerifyNewCycleKey => "FailedToVerifyNewCycleKey",
            Self::FailedToVerifyOldKeyDuringCycle => "FailedToVerifyOldKeyDuringCycle",
            Self::FailedToVerifyKProof => "FailedToVerifyKProof",
            Self::FailedToVerifyAProof => "FailedToVerifyAProof",
            Self::TokenOutOfInterval => "TokenOutOfInterval",
            Self::NoAdminFound => "NoAdminFound",
            Self::UuidTaken => "UuidTaken",
            Self::PublicKeyNotUnique => "PublicKeyNotUnique",
            Self::Misc(_) => "Misc",
            Self::StoreFailure(_) => "StoreFailure",
            Self::CycleRequired => "CycleRequired",
            Self::TokenInRevocationList => "TokenInRevocationList",
            Self::TokenDuplicate => "TokenDuplicate",
            Self::InvalidClientUuid => "InvalidClientUuid",
            Self::TokenExpired => "TokenExpired",
            Self::TokenDoesNotExist => "TokenDoesNotExist",
            Self::TokenPermissionError(_) => "TokenPermissionError",
            Self::FailedToVerifyRevocationRequest => "FailedToVerifyRevocationRequest",
            Self::FailedToVerifyDeregisterHash => "FailedToVerifyDeregisterHash",
            Self::UnauthorizedTokenRequest => "UnauthorizedTokenRequest",
            Self::RevocationClaimantNotFound => "RevocationClaimantNotFound",
            Self::MalformedPkFetch => "MalformedPkFetch",
            Self::DeregistrationClaimantNotFound => "DeregistrationClaimantNotFound",
            Self::UnauthorizedDeregisterRequest => "UnauthorizedDeregisterRequest",
            Self::DeregstrationUnchanged => "DeregstrationUnchanged",
            Self::DeregistrationError(_) => "DeregistrationError"
        }
    }
}


#[derive(thiserror::Error, Debug)]
pub enum ClientProtocolError {
    #[error("Failed to generate the digital signing key pair for cycling/registration")]
    FailedToGenerateDsaPair,
    #[error("Failed to generate the decap key/encap key pair.")]
    FailedToGenerateKemPair,
    #[error("Failed to verify the server signature on the cycle request response.")]
    InauthenticCycleResponse,
    #[error("Failed to verify the server signature on the token request response.")]
    InauthenticTokenResponse,
    #[error("Failed to decapsulate the ciphertext.")]
    DecapsulationError,
    #[error("Failed to sign a message with the client private key.")]
    FailedToSignRequest,
    #[error("Failed to generate the k-proof on the original registration request.")]
    KProofSignError,
    #[error("Failed to generate the a-proof on the original registration request.")]
    AProofSignError,
    #[error("Failed to verify the identity hash which is part of the registration process.")]
    FailedToVerifyIdentityHash,
    #[error("Failed to verify the server signature on the register response.")]
    InauthenticRegisterResponse,
    #[error("Failed to verify the hash returned by the server on the cycle response.")]
    FailedToVerifyCycleHash,
    #[error("Failed to verify the approval hash, as in, the exact hash was not reconstructed on the client end.")]
    FailedToReconstructApprovalHash,
    #[error("Server protocol failure.")]
    ServerError(#[from] ServerProtocolError),
    #[error("Failed to sign a revocation request with the provided key.")]
    FailedToSignRevokeRequest,
    #[error("Failed to validate the hash sent back to confirm revocation")]
    FailedToValidateRevocationHash,
    #[error("Failed to authenticate revocation response.")]
    FailedToAuthenticateRevocationResponse,
    #[error("The server sent back a deregistration hash, but it did not correspond to the calculated hash on the client end.")]
    FailedToVerifyDeregisterHash,
    #[error("Failed to authenticate server response for the deregister message.")]
    FailedToAuthenticateDeregisterResponse
}



impl From<ServerProtocolError> for String {
    fn from(value: ServerProtocolError) -> Self {
        value.to_string()
    }
}

impl From<ClientProtocolError> for String {
    fn from(value: ClientProtocolError) -> Self {
        value.to_string()
    }
}


